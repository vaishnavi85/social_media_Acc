# -*- coding: utf-8 -*-
"""social_media_account_recommendation_system .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15IagnQNd701a1Gy4czfqrrGTxnRXHbkq

"""

pip install pandas numpy scikit-learn

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load dataset containing account details and user interactions
data = pd.read_csv("socialmedia.csv") 

# Preview data
print(data.head())

# Combine description and tags for content-based filtering
data['content'] = data['User Bio'] + " " + data['Hashtags']

# Vectorize the content using TF-IDF
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(data['content'])

# Compute cosine similarity between accounts
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Create a function to get recommendations
def recommend_accounts(Username, data, cosine_sim):
    # Get the index of the account
    idx = data[data['Username'] == Username].index[0]

    # Get similarity scores
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort accounts by similarity score
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the top 5 recommendations (excluding itself)
    sim_scores = sim_scores[1:6]

    # Get account indices
    account_indices = [i[0] for i in sim_scores]

    # Return the top 5 recommended accounts
    return data['Username'].iloc[account_indices]

# Example usage
print(recommend_accounts("@adventureSeeker", data, cosine_sim))

# Inspect column names thoroughly to find any hidden characters or inconsistencies
for col in data.columns:
    print(repr(col))  # This will show hidden characters 

# Strip spaces and replace any other non-visible characters in column names
data.columns = data.columns.str.strip().str.replace(r'\s+', '_', regex=True) 
# Print columns after cleanup
print(data.columns)

# Checking the data types of all columns
print(data.dtypes)

# Checking a few rows to ensure data is properly loaded
print(data.head())

# Checking if there are any missing values in the DataFrame
print(data.isnull().sum())

# Print column names to ensure 'user_id' exists
print(data.columns)

# Try accessing it directly by position
print(data.iloc[:, 0].head()) 

# Explicitly rename the column
data = data.rename(columns={data.columns[0]: 'User_Id'})  

# Verify column names again
print(data.columns)

# Access the 'user_id' column now
print(data['User_Id'].dtype)

# Pivot data to create a user-account interaction matrix
interaction_matrix = data.pivot_table(index='User_Id', columns='Username', values='User_Interactions', fill_value=0)

# View the interaction matrix
print(interaction_matrix.head())

# Compute user similarity
user_similarity = cosine_similarity(interaction_matrix)

# Convert similarity matrix to DataFrame
user_similarity_df = pd.DataFrame(user_similarity, index=interaction_matrix.index, columns=interaction_matrix.index)

# Create a function to recommend accounts based on user similarity
def recommend_for_user(User_Id, interaction_matrix, user_similarity_df):
    # Get similar users
    similar_users = user_similarity_df[User_Id].sort_values(ascending=False).iloc[1:6]

    # Aggregate recommendations
    recommended_accounts = interaction_matrix.loc[similar_users.index].mean().sort_values(ascending=False).head(5)

    # Return account IDs
    return recommended_accounts.index

# Example usage
print(recommend_for_user(712, interaction_matrix, user_similarity_df))

def hybrid_recommendation(User_Id, account_name, data, cosine_sim, interaction_matrix, user_similarity_df):
    # Get content-based recommendations
    content_recs = recommend_accounts(account_name, data, cosine_sim)

    # Get collaborative recommendations
    collaborative_recs = recommend_for_user(User_Id, interaction_matrix, user_similarity_df)

    # Combine recommendations
    hybrid_recs = set(content_recs).union(set(collaborative_recs))
    return hybrid_recs

# Example usage
print(hybrid_recommendation(712, "@techGeek", data, cosine_sim, interaction_matrix, user_similarity_df))

# Precision@K
def precision_at_k(recommended, relevant, k):
    return len(set(recommended[:k]) & set(relevant)) / k

# Example evaluation
recommended_accounts = ["TechGuru", "CodeMaster", "AITrends"]
relevant_accounts = ["CodeMaster", "AITrends", "DataPros"]
print(precision_at_k(recommended_accounts, relevant_accounts, k=3))

